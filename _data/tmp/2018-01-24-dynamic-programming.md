---
layout: post
title: "[알고리즘 설계] 3. 동적계획법(Dynamic Programming)"
subtitle: "algorithm1"
categories: ps
tags: algorithm
---

> 동적계획법도 어떤 문제를 풀기 위해 작은 부분문제들의 해를 이용하여 푸는 방법입니다. 이 기법을 이해하기 위해 여러가지 예제를 통해 설명하고 실제 문제를 풀면서 구현해보는 것이 목표입니다.

## 동적계획법 (Dynamic Programming)
---

동적계획법은 알고리즘 문제에서 가장 자주 나오면서 다양한 문제들을 해결할 수 있는 방법입니다. `Dynamic Programming` 이라고 하지만 실제 프로그래밍에서 접하는 동적 프로그래밍 개념과는 전혀 관련이 없습니다.

동적계획법은 분할정복과 비슷하게 문제를 작은 부분문제로 나눠서 문제를 해결합니다. 다만 차이점은 문제를 어떻게 분할하느냐에 따라 다릅니다. 동적계획법에서는 부분문제들이 여러번 사용되도록 문제를 분할합니다. 따라서 이미 구한 문제는 캐시 메모리에 넣어 한번 구한 문제의 해는 연산하지 않고 메모리의 값을 사용해 효율적으로 최적해를 계산할 수 있습니다.

### 동적계획법 알고리즘

동적계획법은 다음과 같은 3단계로 이루어집니다.

1. 전체문제의 해가 부분문제의 해를 포함하도록 문제를 분할한다.
2. 부분문제의 해를 구한 후 메모리에 저장한다. (이미 구했다면 메모리에 있는 해를 사용함)
3. 부분문제의 해를 이용해 전체문제의 해를 구한다.

이 알고리즘은 한 두번만 구현하면 쉽게 이해되실 겁니다. 다만 동적계획법을 적용가능한 조건을 반드시 숙지하고 있어야 문제에 적용가능한지 판단할 수 있습니다.

### 동적계획법 적용 조건

1. 최적 부분구조(Optimal Substructure) : 전체문제의 최적해는 부분문제의 최적해만으로 구할 수 있도록 분할가능함

2. 중복되는 부분문제(Overlapping Subproblems) : 부분문제가 두번이상 중복됨

예제를 통해 이 2가지 조건을 설명하겠습니다.

## 동적계획법 사고연습
---


```
예제1: 피보나치 수열의 N번째 수 F(N)은 ?
       (단, 0 <= N <= 1000 이고, F(0) = F(1) = 1)

# 피보나치 수열: F(N) = F(N-1) + F(N+2)   
```

> 이 문제는 N이 커짐에 따라 오버플로우가 발생하지만 설명과 무관하므로 무시합니다.

완전탐색으로 이 문제를 풀면 위 관계식을 그대로 재귀로 아래 코드처럼 구현하면 쉽게 구할 수 있습니다. 하지만 시간복잡도는 O(2^N) 이 됩니다.

```C
int Fibo(int n)
{
	if(n==0 || n==1) return 1;
	
	return Fibo(n-1) + Fibo(n-2);
}
```

동적계획법으로 문제를 접근하면 훨씬 효율적으로 구할 수 있습니다.

![]()

그림처럼 피보나치 수열의 정의에 따라 F(N) 을 구하기 위해서는 F(N-1) 와 F(N-2) 의 해를 알기만 하면 됩니다. 다시 말하면 부분문제의 해만으로 전체문제의 해를 구할 수 있습니다. 즉 `최적부분구조`가 성립합니다.

또한 F(6)을 구한다면 모든 부분문제는 1~6 까지 6개의 해만 있으면 됩니다. 일반화하면 F(N)을 구하기 위해서는 N개의 문제에 대한 답만 있으면 됩니다. 즉 `중복되는 부분문제`가 성립함을 의미합니다.

시간복잡도는 부분문제를 알고 있을 때 전체문제는 O(1) 로 구할 수 있고, 모든 부분문제는 N개 뿐이므로 전체 시간복잡도는 O(N) 이 됩니다.

코드를 보면 더 쉽게 이해되실 겁니다.

```C
#define MAXN 1001
int f[MAXN];

f[0] = f[1] = 1;

for(int i=2; i<MAXN; i++)
{
	f[i] = f[i-1] + f[i-2];
}
```

다른 예제도 똑같은 접근을 해봅시다.

```
예제2: N, R 값이 주어질 때, 이항계수 nCr 값은 ? 
      (단, 1<= N <= 1000 이고 0 <= R <= N)

# 이항계수 관계식 : n C r = (n-1)C(r-1) + (n-1) C r
```

> 이 문제는 N, R 값이 커짐에 따라 오버플로우가 발생하지만 설명과 무관하므로 무시합니다.


완전탐색(재귀) : O(2^N)
```C
int Bino(int n, int r)
{
	if(r == 0 || n == r) return 1;
	
	return Bino(n-1, r-1) + Bino(n-1, r);
}
```

마찬가지로 이항계수 관계식에 따라 `최적부분구조`가 성립하며, 이항계수 문제의 종류가 N * ()


## 연습문제
---

> 문제 링크:: 수 정렬하기 2(https://www.acmicpc.net/problem/1182)

> 자세한 문제 설명은 위 링크로 들어가셔서 확인하시고 직접 풀어보세요!

분할정복에서 기본적인 문제로 위에서 '예제2'로 다룬 수 정렬하기 문제입니다. 분할정복을 이해하는 것이 목적이니 라이브러리는 사용하지 않고 직접 구현해보시길 바랍니다. 

### 풀이
---

N의 제약은 100만 이므로 버블정렬, 선택정렬과 같이 O(N^2) 방법은 시간초과로 풀 수 없습니다. 따라서 이 포스팅에서 배운 분할정복 기법을 이용한 병합정렬로 구현하시면 됩니다.

병합정렬은 시간복잡도가 O(NlogN) 이기 때문에 무난하게 통과하실 것입니다.

전체 코드:
```C
#include <stdio.h>
#define MAXN 1000005

int N;
int arr[MAXN];
int tmp[MAXN];

void MergeSort(int l, int r)
{
	if (l >= r) return;
	int m = (l + r) >> 1;

	MergeSort(l, m);
	MergeSort(m + 1, r);

	int p1 = l, p2 = m + 1, p3 = l;
	while (p1 <= m && p2 <= r) 
		tmp[p3++] = (arr[p1] < arr[p2]) ? arr[p1++] : arr[p2++];
	while (p1 <= m) 
		tmp[p3++] = arr[p1++];
	while (p2 <= r) 
		tmp[p3++] = arr[p2++];

	for (int i = l; i <= r; i++) 
		arr[i] = tmp[i];
}

int main()
{
	scanf("%d", &N);
	for (int i = 0; i < N; i++) 
		scanf("%d", &arr[i]);

	MergeSort(0, N - 1);

	for (int i = 0; i < N; i++) 
		printf("%d\n", arr[i]);

	return 0;
}
```

위와 같이 재귀함수로 간단하게 분할정복을 이용한 정렬을 하실 수 있습니다.

## 다른 연습문제 추천
---

- 하노이 탑 이동 순서: (https://www.acmicpc.net/problem/11729)
- 히스토그램에서 가장 큰 직사각형: (https://www.acmicpc.net/problem/6549)

---
분할정복은 특정한 상황에 효율적인 방법이므로 적용 방식에 대해 이해하셨다가 문제 푸실 때 비슷한 상황에서 접근해볼만한 알고리즘입니다.