---
layout: post
title: "[알고리즘 설계] 3. 동적계획법(Dynamic Programming)"
subtitle: "algorithm1"
categories: ps
tags: algorithm
---

> 동적계획법은 [분할정복]()처럼 어떤 문제를 풀 때 부분문제들의 해를 이용하여 해결하는 방법입니다. 동적계획법을 이해하기 위해 여러가지 예제를 통해 설명하고 연습문제를 풀어보면서 직접 구현해보는 것이 목표입니다.

## 동적계획법 (Dynamic Programming)
---

동적계획법은 알고리즘 문제에서 정말 다양하게 등장하기 때문에 많은 문제들을 해결할 수 있습니다. `Dynamic Programming` 이라고 하지만 일반적인 프로그래밍에서 말하는 동적 프로그래밍 개념과는 전혀 관련이 없습니다.

동적계획법은 [분할정복]()과 접근 방식이 비슷하게 문제를 작은 부분문제로 나눠서 해결합니다. 다만 차이점은 문제를 어떻게 나누냐가 다릅니다. 동적계획법에서는 부분문제들이 여러번 사용되도록 문제를 분할합니다. 따라서 이미 해결한 문제는 캐시 메모리에 넣어두고 한번 구한 문제의 해는 연산하지 않고 메모리에 있는 값을 사용하기 때문에 효율적으로 최적해를 계산할 수 있습니다.

동적계획법에서 가장 중요한 2가지 조건이 있습니다. 이 조건을 만족해야만 동적계획법이 잘 적용될 수 있습니다.

### 동적계획법 적용조건

1. 최적부분구조(Optimal Substructure) : 전체문제의 해는 부분문제의 해만으로 구할 수 있도록 분할가능함

2. 중복되는 부분문제(Overlapping Subproblems) : 부분문제가 두 번이상 중복됨

![]()

그림처럼 서울에서 부산가는 최단경로를 구해야 한다고 하면, (서울 -> 대전)의 최단경로와 (대전 -> 부산)의 최단경로의 합으로 구할 수 있습니다. 즉 `최적부분구조`가 성립하게 됩니다. 

하지만 고속도로 통행료 만원 이하로 최단경로를 구하라는 문제로 바꾸면 (서울 -> 대전)의 최단경로와 (대전-> 부산)의 최단경로에서 각각 얼마 통행료를 쓰느냐에 따라 경로가 달라질 수 있기 때문에 부분문제의 해만으로는 정확한 해를 구할 수 없습니다. 즉 `최적부분구조`가 성립하지 않습니다.

`중복되는 부분문제`는 (서울->부산)의 문제를 해결하기 위해 부분문제로 분할하다가 (서울->인천) 경로를 구해야할 수도 있고, (서울 -> 대전) 경로를 분할하다가 다시 (서울 -> 인천) 로 중복된 문제를 해결해야할 수도 있습니다. 이처럼 부분문제로 분할하는 과정에서 같은 문제가 반복되는 문제를 말합니다.

위 두가지 조건을 만족하면 다음과 같은 동적계획법 알고리즘을 이용합니다.

### 동적계획법 알고리즘

1. 전체문제의 해가 부분문제의 해를 포함하도록 문제를 분할한다.
2. 부분문제의 해를 구한 후 메모리에 저장한다. (이미 구했다면 메모리의 값을 사용)
3. 부분문제의 해를 이용해 전체문제의 해를 구한다.

이 알고리즘은 한 두번만 구현하면 쉽게 이해되실 겁니다. 다만 동적계획법을 적용가능한 조건은 반드시 숙지하고 있어야 문제에 적용가능한지 판단할 수 있습니다.

## 동적계획법 사고연습
---

```
예제1: 피보나치 수열의 N번째 수 F(N)은 ?
       (단, 0 <= N <= 1000 이고, F(0) = F(1) = 1)

# 피보나치 수열: F(N) = F(N-1) + F(N+2)   
```

> 이 문제는 N이 커짐에 따라 오버플로우가 발생하지만 설명과 무관하므로 무시합니다.

완전탐색으로 이 문제를 풀면 위 관계식을 그대로 재귀로 아래 코드처럼 구현하면 쉽게 구할 수 있습니다. 하지만 시간복잡도는 O(2^N) 이 됩니다.

```C
int Fibo(int n)
{
	if(n == 0 || n == 1) return 1;
	
	return Fibo(n-1) + Fibo(n-2);
}
```

동적계획법으로 문제를 접근하면 훨씬 효율적으로 구할 수 있습니다.

![]()

그림처럼 피보나치 수열의 정의에 따라 F(N) 을 구하기 위해서는 F(N-1) 와 F(N-2) 의 해를 알기만 하면 됩니다. 다시 말하면 부분문제의 해만으로 전체문제의 해를 구할 수 있습니다. 즉 `최적부분구조`가 성립합니다.

또한 F(6)을 구한다면 모든 부분문제는 1~6 까지 6개의 해만 있으면 됩니다. 일반화하면 F(N)을 구하기 위해서는 N개의 문제에 대한 답만 있으면 됩니다. 즉 `중복되는 부분문제`가 성립함을 의미합니다.

시간복잡도는 부분문제를 알고 있을 때 전체문제는 O(1) 로 구할 수 있고, 모든 부분문제는 N개 뿐이므로 전체 시간복잡도는 O(N) 이 됩니다.

코드를 보면 더 쉽게 이해되실 겁니다.

```C
#define MAXN 1001
int f[MAXN];

f[0] = f[1] = 1;

for(int i=2; i<MAXN; i++)
{
	f[i] = f[i-1] + f[i-2];
}
```

다른 예제도 똑같은 접근을 해봅시다.

```
예제2: N, R 값이 주어질 때, 이항계수 nCr 값은 ? 
      (단, 1<= N <= 1000 이고 0 <= R <= N)

# 이항계수 관계식 : n C r = (n-1) C (r-1) + (n-1) C r
```

> 이 문제도 N, R 값이 커짐에 따라 오버플로우가 발생하지만 설명과 무관하므로 무시합니다.

이 문제도 동적계획법으로 접근하면 이항계수 관계식에 따라 `최적부분구조`가 성립하며, 재귀로 문제를 풀면 이항계수 부분 문제의 종류도 N*R 크기 안에서 중복되어 나타나기 때문에 `중복되는 부분문제`가 발생합니다. 

따라서 동적계획법을 사용하면
```C

```
이렇게 모든 이항계수의 값을 구하는데 O(N*R) 로 가능합니다.

## 연습문제
---

> 문제 링크:: 가장 긴 증가하는 부분수열(https://www.acmicpc.net/roblem/11053)

> 주어진 수열에서 순서는 유지한채로 숫자들을 선택하여 가장 긴 증가하는 수열을 찾아내는 문제입니다. 이 문제는 [LIS(Longest Increasing Subsequence)]() 라고 합니다. 연습문제에서는 가장 긴 길이가 몇인지만 구하면 됩니다.
 
### 풀이
---

동적계획법으로 쉽게 풀 수 있는 문제입니다. `최적부분구조`, `중복되는 부분문제` 이 2가지 조건을 만족하도록 부분문제를 어떻게 분할할 것인지를 생각해내는 것이 중요합니다.

- 문제정의 : dp[n] = 수열의 n번째에서 시작하여 LIS의 길이
- 관계식 : dp[n] = max(1, dp[n-i] + 1) where 0<j<i and a[i] < a[j]

그림처럼 문제정의를 하게 되면 관계식을 도출할 수 있습니다. 이 관계식을 통해 `최적부분구조` 가 성립함을 알 수 있고, 부분문제의 종류는 N개 밖에 없으니 `중복되는 부분문제`가 발생합니다.

따라서 동적계획법을 사용하면 부분 문제를 푸는데 O(N), 부분 문제의 개수는 N개 로 전체 시간복잡도가 O(N^2) 이므로 이 문제의 제약조건인 N <= 1000 안에서 제한시간 내 모든 문제를 해결할 수 있습니다.

전체 코드:
```C

```

이 문제는 최장 길이만 찾으면 됐지만 만약 어떤 부분 수열로 최장 길이가 되는지를 찾으라고 해도 `dp[]` 메모리값을 이용하면 어떤 수열인지도 알 수 있습니다. 이처럼 동적계획법 문제에서는 최적해뿐만 아니라 어떤 조합으로 최적해가 되는지도 구할 수 있습니다.

## 다른 연습문제 추천
---

- 1로 만들기: (https://www.acmicpc.net/problem/1463)
- 정수 삼각형: (https://www.acmicpc.net/problem/1932)

---
동적계획법은 이 글에서 다루지 못한 테크닉도 너무 많아 연습문제가 수두룩하게 있습니다. 여러가지 문제를 풀어보면서 접근 방식에 익숙해지면 좋을 것 같습니다.