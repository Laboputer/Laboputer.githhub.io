---
layout: post
title: "[알고리즘 설계] 4. 탐욕법(Greedy)"
subtitle: "algorithm1"
categories: ps
tags: algorithm
---

> 탐욕법은 보통 최적해를 구하기 어려울 때 근사해를 찾는 방법론입니다. 하지만 특정 조건에서는 탐욕법으로도 최적해인 경우가 있는데 이런 경우 알고리즘 문제로 등장하기도 합니다. 이러한 탐욕법 관련된 예제를 통해 설명하고 연습문제를 풀어보면서 직접 구현해보는 것이 목표입니다.

## 탐욕법 (Greedy)
---

[탐욕법(Greedy)](https://en.wikipedia.org/wiki/Greedy_algorithm)은 [완전탐색](https://laboputer.github.io/ps/2018/01/03/exhaustive-search/)과 [동적계획법](https://laboputer.github.io/ps/2018/02/13/dynamic-programming/) 처럼 모든 경우를 탐색하여 계산한 결과를 바탕으로 구하는 것이 아니라 매순간(지역적인) 최적의 해만 선택하는 방법을 말합니다. 

최단경로를 찾는 문제를 예로 들면, 서울에서 부산까지 최단경로를 찾기위해 모든경로를 탐색해보는 것이 아니라 서울에서 현재 갈 수 있는 지역 중 가장 가까운 도로만을 이용하면서 부산에 도달할 수도 있습니다. 이렇게 탐색하면 당연히 훨씬 빠를 수 밖에 없습니다. 하지만 최단경로에 꽤 가까운 답을 낼 수 있겠지만 실제 최단경로는 아닐 가능성이 높습니다. 이처럼 대부분의 문제는 탐욕법은 최적해를 구할 수 없지만 근사해를 구해야할 경우 유용할 수는 있습니다.

하지만 탐욕법도 `어떤 조건` 하에서는 최적해일 수 있습니다. Problem Solving 에서는 이러한 문제가 등장합니다. 그래서 우리는 탐욕법이 최적해를 구할 수 있는 `이 조건`에 대해서 깊게 고민해볼 것입니다.

탐욕법에서 최적해를 구할 수 있으려면 2가지 조건이 성립해야 합니다.

### 탐욕법의 최적해 조건

1. [최적부분구조(Optimal Substructure)](https://en.wikipedia.org/wiki/Optimal_substructure)
	- 전체문제의 해를 부분문제들의 해만으로도 구할 수 있게 분할가능한 구조

2. [탐욕적 선택 속성(Greedy Choise Property)](https://en.wikipedia.org/wiki/Greedy_algorithm#:~:text=Greedy%20choice%20property)
	- 지역적인 최적의 선택이 전체문제의 해에 반드시 포함됨


`최적부분구조`는 [동적계획법](https://laboputer.github.io/ps/2018/02/13/dynamic-programming/)에서의 그 조건과 동일합니다.

`탐욕적 선택 속성`은 의미 그대로 지역적인 최적의 선택이 전체문제의 최적해를 구할 때도 사용된다는 것입니다.

이 두 가지 속성이 성립하면 당연히 탐욕법은 최적해를 구할 수 있게 됩니다. 왜냐하면 `탐욕적 선택 속성`에 의해 현재 상태에서 최적의 선택이 최종 선택의 해에 포함되며 `최적부분구조`에 의해 부분 문제의 해만으로 전체 문제의 최적해를 구할 수 있기 때문입니다.

## 탐욕법 사고연습
---


### 예제1. 동전 종류가 4가지(10원, 50원, 100원, 500원)이 있을 때, N 원을 가지기 위한 최소 동전의 개수는?
```
단, N은 1억 이하
```

완전탐색() 접근:

4가지 동전을 한번씩 사용해보는 재귀를 이용해서 모든 경우를 탐색할 수 있습니다. 하지만 시간복잡도가 O(4^x) 로 지수승에 가깝습니다.

> x 값은 구하기 쉽지 않지만 500원을 기준으로 해도 1억/500 = 20만으로 매우 큰 값입니다.

동적계획법() 접근:

```
d[N] : N원을 표현하는 최소 동전 개수
```
이렇게 문제를 정의하면 관계식도 쉽게 찾을 수 있습니다. 하지만 N의 값이 아주 크기 때문에 메모리로 표현하기 어렵고, N의 값이 크다는 것은 구해야 하는 부분문제도 종류가 많다는 것을 의미합니다. 이 방법도 좋은 방법은 아닌 것 같습니다.

탐욕법() 접근:

먼저 탐욕법으로 해결 가능한지 확인하기 위해 2가지 속성이 성립하는지 확인해야 합니다.

![]()

`최적부분구조`는 그림과 같은 관계식으로 쉽게 증명됩니다. 

`탐욕적 선택 속성`은 좀 풀어서 설명하면 N 이 500 보다 크면 반드시 500원 짜리 동전을 사용하는 것이 좋습니다. 왜냐하면 500원을 표현할 때 다른 동전으로는 절대로 적은 개수로 표현할 수 없기 때문입니다.  

이 문제는 4가지 동전을 하나씩 사용하면서 탐색해볼 것이 아니라 가장 큰 동전만을 계속 선택하면 됩니다.

그러면 시간복잡도는 O(1) 입니다. 

```C
int coins[4] = {500, 100, 50, 10};

int count = 0;
for(int i=0; i<4; i++)
{
	if (N / coins[i])
	{
		count += N / coins[i];
		N %= coins[i];
	}
}
// Result
printf("%d\n", count);
```

위와 같은 예제가 조건이 살짝 바뀌어 동전의 종류가 400원 짜리가 하나 추가되면 어떻게 될까요?

### 예제 1-2: 동전 종류가 5가지 (10원, 50원, 100원, 400원, 500원) 이라면?
```

이 문제는 `최적부분구조`가 성립하지만, `탐욕적 선택 속성`이 성립하지 않기 때문에 탐욕법으로 풀 수 없습니다.

N = 800 인 경우, 위의 탐욕법으로 계산하면 4 (500원*1, 100원*3) 이지만 최적해는 2 (400원*2) 입니다. `탐욕적 선택 속성`이 성립하지 않기 때문에 지역적 최적의 선택이 최적해를 포함하지 않습니다.

이 문제에서 `탐욕적 선택 속성`이 성립하려면 모든 동전의 종류가 각 동전의 배수여야 합니다. 그래야만 작은 동전을 X개 사용했을 때 더 큰 동전으로 대체할 수 있기 때문입니다.

이렇게 탐욕법은 2가지 속성만 확인되면 아주 빠른 속도로 해를 구할 수 있지만 `탐욕적 선택 속성`을 찾아 증명하는게 쉽지 않습니다.

## 연습문제
---

> 문제 링크:: 가장 긴 증가하는 부분수열(https://www.acmicpc.net/roblem/11053)

> 주어진 수열에서 순서는 유지한채로 숫자들을 선택하여 가장 긴 증가하는 수열을 찾아내는 문제입니다. 이 문제는 [LIS(Longest Increasing Subsequence)]() 라고 합니다. 연습문제에서는 가장 긴 길이가 몇인지만 구하면 됩니다.
 
### 풀이
---

동적계획법으로 쉽게 풀 수 있는 문제입니다. `최적부분구조`, `중복되는 부분문제` 이 2가지 조건을 만족하도록 부분문제를 어떻게 분할할 것인지를 생각해내는 것이 중요합니다.

- 문제정의 : dp[n] = 수열의 n번째에서 시작하여 LIS의 길이
- 관계식 : dp[n] = max(1, dp[n-i] + 1) where 0<j<i and a[i] < a[j]

그림처럼 문제정의를 하게 되면 관계식을 도출할 수 있습니다. 이 관계식을 통해 `최적부분구조` 가 성립함을 알 수 있고, 부분문제의 종류는 N개 밖에 없으니 `중복되는 부분문제`가 발생합니다.

따라서 동적계획법을 사용하면 부분 문제를 푸는데 O(N), 부분 문제의 개수는 N개 로 전체 시간복잡도가 O(N^2) 이므로 이 문제의 제약조건인 N <= 1000 안에서 제한시간 내 모든 문제를 해결할 수 있습니다.

전체 코드:
```C

```

이 문제는 최장 길이만 찾으면 됐지만 만약 어떤 부분 수열로 최장 길이가 되는지를 찾으라고 해도 `dp[]` 메모리값을 이용하면 어떤 수열인지도 알 수 있습니다. 이처럼 동적계획법 문제에서는 최적해뿐만 아니라 어떤 조합으로 최적해가 되는지도 구할 수 있습니다.

## 다른 연습문제 추천
---

- 1로 만들기: (https://www.acmicpc.net/problem/1463)
- 정수 삼각형: (https://www.acmicpc.net/problem/1932)

---
동적계획법은 이 글에서 다루지 못한 테크닉도 너무 많아 연습문제가 수두룩하게 있습니다. 여러가지 문제를 풀어보면서 접근 방식에 익숙해지면 좋을 것 같습니다.