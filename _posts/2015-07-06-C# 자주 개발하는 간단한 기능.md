---
layout: post
title:  "C# 자주 개발하는 간단한 기능"
date:   2015-07-06 17:04:00
categories: Programming(C#)
tags: C#
---

* content
{:toc}



## 이미지와 문자열 변환

이미지 파일을 다룰 때 사용하던 것.

BitmapImage to String
```
if ((checkStream = openFileDialog.OpenFile()) != null)
                    {
                        BitmapImage src = new BitmapImage(new Uri(openFileDialog.FileName));
                        Profile_image.Source = src; //Image
 
                        image = ImageToStringConvert(src);
                    }
 
 public static string ImageToStringConvert(BitmapImage Bitmapimage)
        {
            //BitmapImage To Byte[] Data
            MemoryStream memStream = new MemoryStream();
            JpegBitmapEncoder encoder = new JpegBitmapEncoder();
            encoder.Frames.Add(BitmapFrame.Create(Bitmapimage));
            encoder.Save(memStream);
 
            byte[] Image_BinaryData = memStream.GetBuffer();
 
            // BinaryData To StringData
            string ImageString = Convert.ToBase64String(Image_BinaryData);
 
            return ImageString;
        }
```

이미지 파일을 선택하면 BitmapImage 객체로 받을 수 있다.
Image객체의 Source Property는 ImageSource 객체인데 BitmapImage 에서 자동 형변환된다.

만약 실제 ImageToString을 구현하고 싶으면 Source값을 넣어준 image객체를 매개변수로 넣는 것으로 바꾸면 됩니다.

String to Image
```
public static Image ConvertStringToImage(string str)
     {
         if (str == null || str=="")
             return null;
 
         Image img = new Image();
 
         byte[] jpgimages = Convert.FromBase64String(str);
         MemoryStream streams = new MemoryStream(jpgimages);
         JpegBitmapDecoder decoders = new JpegBitmapDecoder(streams, BitmapCreateOptions.None, BitmapCacheOption.None);
         BitmapSource imagesources = decoders.Frames[0];
         img.Source = imagesources;
 
         return img;
     }
```

## Drag and Drop

```
private void Form1_DragDrop(object sender, DragEventArgs e)
{
	if (e.Data.GetDataPresent(DataFormats.FileDrop))
	{
		string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
		foreach (string filePath in files)
		{
			MessageBox.Show(filePath);
		}
	}
}
private void Form1_DragEnter(object sender, DragEventArgs e)
{
	e.Effect = DragDropEffects.All;
}
```

## Exception 종류

### 인터넷 연결 체크
```
//using webclient
public static bool CheckForInternetConnection()
{
    try
    {
        using (var client = new WebClient())
        using (var stream = client.OpenRead("http://www.google.com"))
        {
            return true;
        }
    }
    catch
    {
        return false;
    }
}
  
// using ping
Ping myPing = new Ping();
String host = "google.com";
byte[] buffer = new byte[32];
int timeout = 1000;
PingOptions pingOptions = new PingOptions();
PingReply reply = myPing.Send(host, timeout, buffer, pingOptions);
if (reply.Status == IPStatus.Success) {
  // presumably online
}
```

## Busy Indicator
코드 상에서 수행시간이 오래 걸리는 기능을 수행할 때 사용자에게 알려주는 기능.

뭐 구체적으로 설명하지 않아도 UX적으로 의미있는 기능이다.

어떤 작업을 수행할 때 시간이 오래 걸리는 기능들(DB쿼리, 파싱 등)을 수행하게 되면 해당 내용이 진행 중임을 UI에 표시해야 되는데, 이게 실시간으로 표시하는 것은 생각보다 쉽지 않다. 왜냐하면 Windows 운영체제에서 UI를 갱신해주는 Windows Message Queue라는 이벤트가 수행되어야 UI 갱신이 이루어지는데 C# 코드 상에서는 이벤트가 발생해 어떤 기능을 수행할 때 모든 것이 완료되어야 이벤트가 종료된후 UI 메시지큐에 들어가기 때문에 운영체제 입장에서는 프리징 되는 현상이 발생한다. 즉, UI가 실시간 갱신이 안된다는 점.

그래서, 비동기 프로그래밍과도 연관이 되어지는데, UI Thread임을 알리는 등의 방법이 있을 수 있다.

Cursor만 WaitCursor로 변경하는 코드

```
    class CustomCursor : IDisposable
    {
        private Cursor _previousCursor;

        public CustomCursor(Cursor newCursor)
        {
            this._previousCursor = Cursor.Current;
            Cursor.Current = newCursor;
        }

        public void Dispose()
        {
            Cursor.Current = _previousCursor;
        }
    }

    class WaitCursor : CustomCursor
    {
        public WaitCursor() : base(Cursors.WaitCursor) { }
    }
    
    // use it like this:
    // using (new WaitCursor())
    // { // Long Task }
```

WPF에서 Busy Indicator

조금 더 UI를 개선시키고 싶을 경우 MVVM 패턴에서 Busy Indicator를 구현해본다.

참고 : https://weblogs.asp.net/psteele/wpf-simple-busy-overlay
```
// Xaml 코드
<<!-- xmlns:local="clr-namespace: yourNamespace"-->

<Window.Resources>
	<local:BoolToVisibilityConverter x:Key="boolConverter"/>
</Window.Resources>

<Grid Background="#80000000" Panel.ZIndex="100" Visibility="{Binding IsBusy, Converter={StaticResource boolConverter}}">
<!--UI-->
	<TextBlock Margin="0" TextWrapping="Wrap" Text="Please Wait..." HorizontalAlignment="Center" VerticalAlignment="Center" FontSize="24" FontWeight="Bold" Foreground="#7EFFFFFF"/>
</Grid>


// Code Behind
public void BusyTask(Action action)
{
	vm.IsBusy = true; // IsBusy Property in ViewModel
	Task.Factory.StartNew(() =>
	{
		action.Invoke();
	}).ContinueWith((task) =>
    {
    	vm.IsBusy = false;
    }, TaskScheduler.FromCurrentSynchronizationContext());
    
    //Use it like this:
// BusyTask(()=>{ //Long Task })
}


//BoolTovisibilityConverter
    class BoolToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            try
            {
                var v = (bool)value;
                return v ? Visibility.Visible : Visibility.Collapsed;
            }
            catch (InvalidCastException)
            {
                return Visibility.Collapsed;
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }


```



