---
layout: post
title:  "C# 자주 개발하는 간단한 기능"
date:   2015-07-06 17:04:00
categories: Programming(C#)
tags: C#
---

* content
{:toc}



## 이미지와 문자열 변환

이미지 파일을 저장할 때 문자열 형식으로 변환하여 저장하는 방법을 다룬다.

BitmapImage to String
```
if ((checkStream = openFileDialog.OpenFile()) != null)
                    {
                        BitmapImage src = new BitmapImage(new Uri(openFileDialog.FileName));
                        Profile_image.Source = src; //Image
 
                        image = ImageToStringConvert(src);
                    }
 
 public static string ImageToStringConvert(BitmapImage Bitmapimage)
        {
            //BitmapImage To Byte[] Data
            MemoryStream memStream = new MemoryStream();
            JpegBitmapEncoder encoder = new JpegBitmapEncoder();
            encoder.Frames.Add(BitmapFrame.Create(Bitmapimage));
            encoder.Save(memStream);
 
            byte[] Image_BinaryData = memStream.GetBuffer();
 
            // BinaryData To StringData
            string ImageString = Convert.ToBase64String(Image_BinaryData);
 
            return ImageString;
        }
```

이미지 파일을 선택하면 BitmapImage 객체로 받을 수 있다.
Image객체의 Source Property는 ImageSource 객체인데 BitmapImage 에서 자동 형변환된다.

만약 실제 ImageToString을 구현하고 싶으면 Source값을 넣어준 image객체를 매개변수로 넣는 것으로 바꾸면 된다.

String to Image
```
public static Image ConvertStringToImage(string str)
     {
         if (str == null || str=="")
             return null;
 
         Image img = new Image();
 
         byte[] jpgimages = Convert.FromBase64String(str);
         MemoryStream streams = new MemoryStream(jpgimages);
         JpegBitmapDecoder decoders = new JpegBitmapDecoder(streams, BitmapCreateOptions.None, BitmapCacheOption.None);
         BitmapSource imagesources = decoders.Frames[0];
         img.Source = imagesources;
 
         return img;
     }
```

## Drag and Drop

C#에서 FileDialog를 사용하지 않고 사용자의 Drag&Drop 형식으로 파일명을 받을 수 있는 방법.

```
private void Form1_DragDrop(object sender, DragEventArgs e)
{
	if (e.Data.GetDataPresent(DataFormats.FileDrop))
	{
		string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
		foreach (string filePath in files)
		{
			MessageBox.Show(filePath);
		}
	}
}
private void Form1_DragEnter(object sender, DragEventArgs e)
{
	e.Effect = DragDropEffects.All;
}
```

## Busy Indicator
코드 상에서 수행시간이 오래 걸리는 기능을 수행할 때 사용자에게 알려주는 기능.

뭐 구체적으로 설명하지 않아도 UX적으로 의미있는 기능이다.

어떤 작업을 수행할 때 시간이 오래 걸리는 기능들(DB쿼리, 파싱 등)을 수행하게 되면 해당 내용이 진행 중임을 UI에 표시해야 되는데, 이게 실시간으로 표시하는 것은 생각보다 쉽지 않다. 왜냐하면 Windows 운영체제에서 UI를 갱신해주는 Windows Message Queue라는 이벤트가 수행되어야 UI 갱신이 이루어지는데 C# 코드 상에서는 이벤트가 발생해 어떤 기능을 수행할 때 모든 것이 완료되어야 이벤트가 종료된후 UI 메시지큐에 들어가기 때문에 운영체제 입장에서는 프리징 되는 현상이 발생한다. 즉, UI가 실시간 갱신이 안된다는 점.

그래서, 비동기 프로그래밍과도 연관이 되어지는데, UI Thread임을 알리는 등의 방법이 있을 수 있다.

Cursor만 WaitCursor로 변경하는 코드

```
    class CustomCursor : IDisposable
    {
        private Cursor _previousCursor;

        public CustomCursor(Cursor newCursor)
        {
            this._previousCursor = Cursor.Current;
            Cursor.Current = newCursor;
        }

        public void Dispose()
        {
            Cursor.Current = _previousCursor;
        }
    }

    class WaitCursor : CustomCursor
    {
        public WaitCursor() : base(Cursors.WaitCursor) { }
    }
    
    // use it like this:
    // using (new WaitCursor())
    // { // Long Task }
```

WPF에서 Busy Indicator

조금 더 UI를 개선시키고 싶을 경우 MVVM 패턴에서 Busy Indicator를 구현해본다.

참고 : https://weblogs.asp.net/psteele/wpf-simple-busy-overlay
```
// Xaml 코드
<<!-- xmlns:local="clr-namespace: yourNamespace"-->

<Window.Resources>
	<local:BoolToVisibilityConverter x:Key="boolConverter"/>
</Window.Resources>

<Grid Background="#80000000" Panel.ZIndex="100" Visibility="{Binding IsBusy, Converter={StaticResource boolConverter}}">
<!--UI-->
	<TextBlock Margin="0" TextWrapping="Wrap" Text="Please Wait..." HorizontalAlignment="Center" VerticalAlignment="Center" FontSize="24" FontWeight="Bold" Foreground="#7EFFFFFF"/>
</Grid>


// Code Behind
public void BusyTask(Action action)
{
	vm.IsBusy = true; // IsBusy Property in ViewModel
	Task.Factory.StartNew(() =>
	{
		action.Invoke();
	}).ContinueWith((task) =>
    {
    	vm.IsBusy = false;
    }, TaskScheduler.FromCurrentSynchronizationContext());
    
    //Use it like this:
// BusyTask(()=>{ //Long Task })
}


//BoolTovisibilityConverter
    class BoolToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            try
            {
                var v = (bool)value;
                return v ? Visibility.Visible : Visibility.Collapsed;
            }
            catch (InvalidCastException)
            {
                return Visibility.Collapsed;
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }


```

## Get Return value from Process
프로그램 상에서 별도의 프로그램을 실행시켜 해당 프로그램의 리턴값을 받을 수 있는 방법.

x64로 실행할 수 있는 프로젝트를 만들던 와중에 별도로 x86 코드를 실행시켜야 하는 경우가 업무 중에 있었다. 그래서 했던 방법으로 x86 프로그램으로 x86 코드를 실행시키고 값을 받는 별도의 프로그램을 만들어 x64 프로그램에서 실행하여 값을 받을 수 있는 코드가 필요했다.

해당 코드는 Process.Start로 해당 .exe를 실행하면 리턴값을 얻을 수 있다.

Code:
```
    using System.Diagnostics;
    enum ExitCode { error, success, normal };
    class ProcessStarter
    {
        public static ExitCode ProcessStart(string fileName, out string result, out string err)
        {
            var proc = new Process
            {
                StartInfo = new ProcessStartInfo(fileName)
                {
                    UseShellExecute=false,
                    RedirectStandardOutput=true,
                    RedirectStandardInput=true,
                    RedirectStandardError=true,
                    CreateNoWindow=true
                }
            };
            proc.Start();
            result = proc.StandardOutput.ReadToEnd();
            err = proc.StandardError.ReadToEnd();
            proc.WaitForExit();
            return (ExitCode)proc.ExitCode;
        }
    }
```





## Exception 종류

### 인터넷 연결 체크
```
//using webclient
public static bool CheckForInternetConnection()
{
    try
    {
        using (var client = new WebClient())
        using (var stream = client.OpenRead("http://www.google.com"))
        {
            return true;
        }
    }
    catch
    {
        return false;
    }
}
  
// using ping
Ping myPing = new Ping();
String host = "google.com";
byte[] buffer = new byte[32];
int timeout = 1000;
PingOptions pingOptions = new PingOptions();
PingReply reply = myPing.Send(host, timeout, buffer, pingOptions);
if (reply.Status == IPStatus.Success) {
  // presumably online
}
```



